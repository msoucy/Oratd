The main change between Oratr and Oratd is that everything returns an object of SOME type.
This means that there has to be a good object system from the beginning.
The syntax for things should, overall, remain the same.
Functions can't be overloaded, but they're treated as objects, instead.

tCode
	Code from ()
	Evaluated at execution time
	eval()s to the return value
tCompoundStatement
	Code from {}
	Stored until later?
	eval() merely executes, doesn't "return" the "return" value
tString
	A standard string
	"" '' are equivalent
	`` is a raw string
tNumeric
	Just a standard number
	Can store either a double or an int
		This means I'll need to make floor() and ceil()
	Supports normal base 10, as well as 0x, 0b, 0o
tRawArray
	String contains the string that will be converted into an array
	[a,b,c] - commas ARE used, now.
	eval()s to a tArray
	Deferred evaluation allows for fewer...problems.
tArray
	An array
	String isn't used at all
	Array stores...the array, duh
tVarname
	Oratr style varnames
	name
	name:offset
	name$type
	The $type can ONLY be the last part of the statement
	eval()s to the data contained within the environment variable with that name
tType
	Stores data about a custom class
	The string portion is the name of the class
	The array is the members
tFunction
	Stores a function
	String is the code to run
	Array stores the arguments by name
tOpcode
	Contains a series of symbols, even the ones that aren't "valid"
	String stores the symbol
	Array is empty


Syntax for some things are changed:
	??? Arrays now REQUIRE commas
	Alias no longer exists
		function [args] {body}
		f = (function [x,y] {return (x+y)})
	Classes will actually WORK, including operators
		class Name {body definition}
		Inside the definition, limited functions are allowed
		The "this" keyword is always possible
			operator + [b] {return this:x + b$num}
			cast num {return x}
	The parser now splits by ; before it goes over each function
		It treats each string set as a new command
	
"Built-in" classes:
	Built in to the interpreter
	No way to derive from them
	num
	str
	arr
		ALWAYS converts a custom class into an array, can't be overloaded
